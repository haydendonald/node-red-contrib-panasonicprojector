"use strict";
/*
 * This file is part of the Companion project
 * Copyright (c) 2018 Bitfocus AS
 * Authors: William Viker <william@bitfocus.io>, Håkon Nessjøen <haakon@bitfocus.io>
 *
 * This program is free software.
 * You should have received a copy of the MIT licence as well as the Bitfocus
 * Individual Contributor License Agreement for companion along with
 * this program.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the Companion software without
 * disclosing the source code of your own applications.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TcpClient = exports.ClientStatus = void 0;
// Rewritten to typescript
const net = require("net");
const events_1 = require("events");
var ClientStatus;
(function (ClientStatus) {
    ClientStatus[ClientStatus["Unkown"] = -1] = "Unkown";
    ClientStatus[ClientStatus["Ok"] = 0] = "Ok";
    ClientStatus[ClientStatus["Warning"] = 1] = "Warning";
    ClientStatus[ClientStatus["Error"] = 2] = "Error";
})(ClientStatus = exports.ClientStatus || (exports.ClientStatus = {}));
const DEFAULT_RECONNECT_INTERVAL = 2000;
const tcpSockets = [];
const debug = () => { };
class TcpClient extends events_1.EventEmitter {
    constructor(host, port, options) {
        super();
        this.connected = false;
        this.status = ClientStatus.Unkown;
        this.trying = false;
        this.failedAttempts = 0;
        this.host = host;
        this.port = port;
        this.options = options === undefined ? {} : options;
        if (this.options.reconnect_interval === undefined) {
            this.options.reconnect_interval = DEFAULT_RECONNECT_INTERVAL;
        }
        if (this.options.reconnect === undefined) {
            this.options.reconnect = true;
        }
        this.socket = new net.Socket();
        this.socket.setKeepAlive(true);
        this.socket.setNoDelay(true);
        debug('new tcp instance for sending to ' + host);
        this.socket.on('error', (err) => {
            this.trying = false;
            this.connected = false;
            if (this.options.reconnect) {
                this.restartReconnect();
            }
            // status levels: null = unknown, 0 = ok, 1 = warning, 2 = error
            debug('error: ' + err.message);
            if (this.status !== ClientStatus.Error) {
                this.new_status(ClientStatus.Error, err.message);
                this.emit('error', err);
            }
        });
        this.socket.on('connect', () => {
            this.failedAttempts = 0;
            this.connected = true;
            this.trying = false;
            this.new_status(ClientStatus.Ok);
            this.emit('connect', this.socket);
        });
        this.socket.on('end', () => {
            debug('Disconnected');
            this.connected = false;
            this.new_status(ClientStatus.Error, 'Disconnected');
            if (!this.trying && this.options.reconnect) {
                this.restartReconnect();
            }
            this.emit('end');
        });
        this.socket.on('data', this.emit.bind(this, 'data'));
        this.socket.on('drain', this.emit.bind(this, 'drain'));
        tcpSockets.push(this.socket);
        debug(tcpSockets.length + ' TCP sockets in use (+1)');
        return this;
    }
    connect() {
        if (!this.trying) {
            this.trying = true;
            this.socket.connect(this.port, this.host);
        }
    }
    write(message, cb) {
        return this.send(message, cb);
    }
    send(message, cb) {
        if (this.connected && message !== undefined) {
            debug('sending ' + message.length + ' bytes to ' + this.host + ':' + this.port);
            this.socket.write(message, (err) => {
                if (err) {
                    this.new_status(ClientStatus.Error, err.message);
                    this.emit('error', err);
                    if (typeof cb === 'function') {
                        cb(err);
                    }
                    return;
                }
                if (typeof cb === 'function') {
                    cb();
                }
            });
            return true;
        }
        else {
            debug('Tried to send, but not connected');
            return false;
        }
    }
    destroy() {
        if (this.tryTimer !== undefined) {
            clearTimeout(this.tryTimer);
        }
        if (tcpSockets.indexOf(this.socket) !== -1) {
            tcpSockets.splice(tcpSockets.indexOf(this.socket), 1);
            debug(tcpSockets.length + ' TCP sockets in use (-1)');
        }
        this.socket.removeAllListeners();
        this.removeAllListeners();
        this.socket.destroy();
    }
    new_status(status, message) {
        if (this.status !== status) {
            this.status = status;
            this.emit('status_change', status, message);
        }
    }
    restartReconnect() {
        if (this.tryTimer !== undefined) {
            clearTimeout(this.tryTimer);
        }
        this.tryTimer = setTimeout(() => this.tcp_reconnect(), this.options.reconnect_interval || DEFAULT_RECONNECT_INTERVAL);
    }
    tcp_reconnect() {
        delete this.tryTimer;
        this.new_status(ClientStatus.Warning, 'Connecting');
        this.failedAttempts++;
        debug('Reconnecting to ' + this.host + ':' + this.port + ', retry ' + this.failedAttempts);
        this.connect();
    }
}
exports.TcpClient = TcpClient;
//# sourceMappingURL=TcpClient.js.map