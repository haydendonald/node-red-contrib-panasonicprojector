"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Projector = void 0;
const events_1 = require("events");
const Client_1 = require("./Client");
const Commands = require("./Commands");
const Responses_1 = require("./Responses");
const EMPTY_LAMBDA = () => { };
const QUERY_INTERVAL_MS = 500;
class CommandState {
    constructor(cmd, connectionFactory, changed, log) {
        this.disabled = false;
        this.log = EMPTY_LAMBDA;
        this.cmd = cmd;
        this.connectionFactory = connectionFactory;
        this.changed = changed;
        if (log !== undefined) {
            this.log = log;
        }
    }
    queryValue() {
        return new Promise((resolve, reject) => {
            const cmd = this.cmd.getQueryCommand();
            if (cmd === undefined) {
                reject(new Error('query command not implemented'));
                return;
            }
            const connection = this.connectionFactory();
            if (connection === undefined) {
                reject(new Error('no connection available'));
                return;
            }
            connection.sendCommand(cmd, this.cmd.type)
                .then(response => {
                const value = this.updateValue(response);
                resolve(value);
            }, err => {
                if (err === Responses_1.ResponseCode.ER401 || err.message === Responses_1.ResponseCode.ER401) {
                    this.disabled = true;
                    this.value = undefined;
                    this.log('warn', 'Disabeling unsupported command: ' + this.cmd.label);
                }
                reject(err);
            });
        });
    }
    updateValue(response) {
        const value = this.cmd.parseResponse(response || '');
        if (this.value !== value) {
            this.value = value;
            if (this.changed !== undefined) {
                this.changed(value);
            }
        }
        return value;
    }
    getValue() {
        return this.value;
    }
    getName() {
        return this.cmd.getName();
    }
    getLabel() {
        return this.cmd.label;
    }
}
class Projector extends events_1.EventEmitter {
    constructor(connection, log) {
        super();
        this.queryList = [];
        this.queryIndex = 0;
        this.log = () => { };
        if (log !== undefined) {
            this.log = log;
        }
        this.updateConnection(connection);
        this.addMonitoring(Commands.PowerCommand);
        this.addMonitoring(Commands.FreezeCommand);
        this.addMonitoring(Commands.ShutterCommand);
        this.addMonitoring(Commands.InputSelectCommand);
        this.addMonitoring(Commands.LampControlStatusCommand);
    }
    updateConnection(connection) {
        if (connection.connected === true) {
            this.init(connection);
        }
        else {
            connection.on(Client_1.Client.Events.CONNECT, () => {
                this.init(connection);
            });
        }
    }
    sendQuery(command) {
        if (this.connection === undefined) {
            return Promise.reject(new Error('no connection available'));
        }
        const formatted = command.getQueryCommand();
        if (formatted !== undefined) {
            const promise = this.connection.sendCommand(formatted, command.type);
            return promise;
        }
        return Promise.reject(new Error('query command not implemented'));
    }
    sendValue(command, value) {
        if (this.connection === undefined) {
            return Promise.reject(new Error('no connection available'));
        }
        const formatted = command.getSetCommand(value);
        if (formatted !== undefined) {
            const conn = this.connection;
            return new Promise((resolve, reject) => {
                conn.sendCommand(formatted, command.type).then(response => {
                    // Update internal state
                    for (const state of this.queryList) {
                        if (state.getName() === command.getName()) {
                            state.updateValue(response);
                            break;
                        }
                    }
                    resolve(response);
                }, reject);
            });
        }
        return Promise.reject(new Error('invalid value or command not implemented'));
    }
    getValue(cmd) {
        for (const item of this.queryList) {
            if (item.getName() === cmd.getName()) {
                return Promise.resolve(item.getValue());
            }
        }
        return new Promise((resolve, reject) => {
            this.sendQuery(cmd).then(response => {
                resolve(cmd.parseResponse(response || ''));
            }, reject);
        });
    }
    /**
     * Adds command to a list of cyclic queried commands.
     * If the result of a command changes, a 'state_change' is triggered
     * with the following signate: (command_label, new_value)
     * @param command The command to be monitored (cyclic querying of the projector)
     */
    addMonitoring(command) {
        const state = new CommandState(command, () => this.connection, v => this.emit(Projector.Events.STATE_CHANGE, command.label, v), this.log);
        this.queryList.push(state);
    }
    removeMonitoring(command) {
        for (const state of this.queryList) {
            if (state.getName() === command.getName()) {
                // Get index in list
                const index = this.queryList.indexOf(state);
                if (index >= 0) {
                    // remove command from list
                    this.queryList.splice(index, 1);
                    return true;
                }
            }
        }
        return false;
    }
    sendToggleCommand(cmd, value) {
        if (value === undefined) {
            this.getValue(cmd).then(v => {
                this.sendValue(cmd, !v).then(EMPTY_LAMBDA, this.onError.bind(this));
            }, this.onError.bind(this));
        }
        else {
            this.sendValue(cmd, value).then(EMPTY_LAMBDA, this.onError.bind(this));
        }
    }
    setPower(power) {
        this.sendToggleCommand(Commands.PowerCommand, power);
    }
    setFreeze(freeze) {
        this.sendToggleCommand(Commands.FreezeCommand, freeze);
    }
    setShutter(shutter) {
        this.sendToggleCommand(Commands.ShutterCommand, shutter);
    }
    setInput(input) {
        this.sendValue(Commands.InputSelectCommand, input).then(EMPTY_LAMBDA, this.onError.bind(this));
    }
    init(connection) {
        if (this.connection !== undefined) {
            // TODO: remove listener?
        }
        this.connection = connection;
        this.sendQuery(Commands.ModelNameCommand).then(response => {
            if (response !== undefined) {
                this.model = Commands.ModelNameCommand.parseResponse(response);
                this.emit(Projector.Events.STATE_CHANGE, 'model', this.model);
            }
            // Query name
            this.sendQuery(Commands.ProjectorNameCommand).then(response => {
                if (response !== undefined) {
                    this.name = Commands.ProjectorNameCommand.parseResponse(response);
                    this.emit(Projector.Events.STATE_CHANGE, 'name', this.name);
                }
            }, this.onError.bind(this));
        }, this.onError.bind(this));
        if (this.queryStateInterval !== undefined) {
            clearInterval(this.queryStateInterval);
            delete this.queryStateInterval;
        }
        // reset command states
        for (const state of this.queryList) {
            state.disabled = false;
        }
        this.queryStateInterval = setInterval(() => this.queryState(), QUERY_INTERVAL_MS);
    }
    queryState() {
        if (this.queryList.length === 0)
            return;
        if (this.queryIndex >= this.queryList.length) {
            this.queryIndex = 0;
        }
        let query;
        while (this.queryIndex < this.queryList.length) {
            if (this.queryList[this.queryIndex].disabled) {
                this.queryIndex += 1;
            }
            else {
                query = this.queryList[this.queryIndex];
                break;
            }
        }
        if (query !== undefined) {
            query.queryValue().then(EMPTY_LAMBDA, EMPTY_LAMBDA);
        }
        this.queryIndex += 1;
    }
    onError(err, cmd) {
        if (cmd !== undefined) {
            this.log('error', 'Command "' + cmd + '" resulted in error: ' + (err.message || err));
        }
        else {
            const msg = err.message || err;
            const description = Responses_1.getResponseDescription(msg);
            if (msg === Responses_1.ResponseCode.ERRA) {
                // Invalid authentication
                if (this.queryStateInterval !== undefined) {
                    clearInterval(this.queryStateInterval);
                    delete this.queryStateInterval;
                }
                // Throttle logging
                // tslint:disable-next-line:tsr-detect-possible-timing-attacks
                if (this.authLogPending === undefined) {
                    this.authLogPending = setTimeout(() => {
                        this.log('error', 'Authentication failed. Invalid credentials.');
                        delete this.authLogPending;
                    }, 250);
                }
            }
            else {
                this.log('error', 'Received error: ' + msg + (description === undefined ? '' : ' (' + description + ')'));
            }
        }
    }
}
exports.Projector = Projector;
Projector.Events = {
    STATE_CHANGE: 'state_change'
};
//# sourceMappingURL=Projector.js.map