"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryCommand = exports.GenericCommand = void 0;
const Types_1 = require("./Types");
class GenericCommand {
    constructor(name, label, converter, options) {
        this.type = Types_1.CommandType.Ascii;
        this.name = name;
        this.label = label;
        this.converter = converter;
        if (options === undefined) {
            options = {};
        }
        this.subname = options.subname;
        this.queryCommand = options.queryCommand === undefined ? ('Q' + this.buildName(true)) : options.queryCommand;
        if (options.setCommand !== undefined) {
            this.setCommand = options.setCommand;
        }
        else {
            this.setCommand = (options.setPrefix === undefined ? 'V' : options.setPrefix)
                + this.buildName();
        }
        if (options.setOperator !== undefined) {
            this.setOperator = options.setOperator;
        }
        else {
            this.setOperator = this.subname === undefined ? ':' : '=';
        }
    }
    buildName(query = false) {
        let name = this.name;
        if (name === 'XX' && query === true) {
            name = 'VX';
        }
        return this.subname === undefined ? name : (name + ':' + this.subname);
    }
    getName() {
        return this.buildName(false);
    }
    parseResponse(response) {
        let value = response;
        if (this.subname !== undefined) {
            const parts = response.split('=');
            if (parts.length === 2) {
                value = parts[1];
            }
        }
        // Projector echoes back complete command on successful "set commands"
        if (value.startsWith(this.setCommand)) {
            // +1 -> also remove the ':' or '=' character
            value = value.substring(this.setCommand.length + 1);
        }
        return this.converter.parse(value);
    }
    getSetCommand(value) {
        const formatted = this.converter.format(value);
        return formatted === undefined
            ? this.setCommand
            : (this.setCommand + this.setOperator + formatted);
    }
    getQueryCommand() {
        return this.queryCommand;
    }
}
exports.GenericCommand = GenericCommand;
class BinaryCommand {
    constructor(name, label, converter) {
        this.type = Types_1.CommandType.Binary;
        this.name = name;
        this.label = label;
        this.converter = converter;
    }
    getName() {
        return this.name;
    }
    parseResponse(response) {
        let value = undefined;
        if (response.substring(0, 2) === '02'
            && response.substring(response.length - 2) === '03'
            && response.substring(4, 4 + this.name.length) === this.name) {
            value = response.substring(4 + this.name.length, response.length - 2);
        }
        else {
            return undefined;
        }
        return this.converter.parse(value);
    }
    getSetCommand(value) {
        const formatted = this.converter.format(value);
        if (formatted === undefined)
            return undefined;
        return '0200' + this.name + formatted + '03';
    }
    getQueryCommand() {
        return undefined;
    }
}
exports.BinaryCommand = BinaryCommand;
//# sourceMappingURL=GenericCommands.js.map