"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const crypto = require("crypto");
const events_1 = require("events");
const TcpClient_1 = require("./TcpClient");
const Responses_1 = require("./Responses");
const Types_1 = require("./Types");
const DEFAULT_PORT = 1024;
const PROTOCOL_LINE_BREAK = '\r';
const AUTO_RESOLVE_TIME = 500;
var ProtocolPrefix;
(function (ProtocolPrefix) {
    ProtocolPrefix["SINGLE_COMMAND_ASCII"] = "00";
    ProtocolPrefix["SINGLE_COMMAND_BINARY"] = "01";
    ProtocolPrefix["PERSISTENT_ASCII"] = "20";
    ProtocolPrefix["PERSISTENT_BIN"] = "21";
})(ProtocolPrefix || (ProtocolPrefix = {}));
/**
 * NT CONTROL connection client.
 */
class Client extends events_1.EventEmitter {
    /**
     * Creates a new NT CONTROL client.
     * @param host      NT CONTROL host/ip address
     * @param port      Port of the NT CONTROL host (default: 1024)
     * @param user      The user (default: 'admin1')
     * @param password  The password (default: 'panasonic')
     */
    constructor(host, port, user, password) {
        super();
        this.receivebuffer = '';
        this.reportConnectionError = true;
        /**
         * Connected state (including initial handshake)
         */
        this.connected = false;
        this.host = host;
        this.port = port || DEFAULT_PORT;
        this.user = user;
        this.password = password;
        this.cmdStack = [];
    }
    connect() {
        this.destroy();
        this.socket = new TcpClient_1.TcpClient(this.host, this.port);
        if (this.host) {
            this.socket.on('error', (err) => {
                if (err && this.reportConnectionError) {
                    this.emit(Client.Events.DEBUG, 'Network error: ' + err);
                    this.reportConnectionError = false;
                }
                // Destory and reconnect (reject all pending responses).
                this.connect();
            });
            this.socket.on('timeout', () => {
                // Destory and reconnect (reject all pending responses).
                this.connect();
            });
            this.socket.on('connect', () => {
                this.emit(Client.Events.DEBUG, 'socket connect');
                this.reportConnectionError = true;
            });
            this.socket.on('end', () => {
                this.emit(Client.Events.END);
            });
            // separate buffered stream into lines with responses
            this.socket.on('data', (chunk) => this.onData(chunk));
            this.socket.on('receiveline', (line) => this.onReceiveLine(line));
            this.socket.connect();
        }
    }
    /**
     * Set authentication information for the connection
     * @param user      The username (default: 'admin1')
     * @param password  The password (default: 'panasonic')
     */
    setAuthentication(user, password) {
        this.user = user;
        this.password = password;
    }
    setToken(salt) {
        if (salt) {
            const user = this.user || '';
            const password = this.password || '';
            this.token = crypto.createHash('md5')
                .update(user + ':' + password + ':' + salt, 'ascii')
                .digest('hex')
                .toUpperCase();
        }
        else {
            this.token = '';
        }
    }
    onData(chunk) {
        let i = 0;
        let line = '';
        let offset = 0;
        this.receivebuffer += chunk;
        while (1) {
            i = this.receivebuffer.indexOf(PROTOCOL_LINE_BREAK, offset);
            if (i === -1)
                break;
            line = this.receivebuffer.substr(offset, i - offset);
            offset = i + 1;
            if (this.socket !== undefined) {
                this.socket.emit('receiveline', line.toString());
            }
        }
        this.receivebuffer = this.receivebuffer.substr(offset);
    }
    onReceiveLine(line) {
        if (line.substring(0, 10) === 'NTCONTROL ') {
            // Greeting after connection setup
            let salt = '';
            if (line[10] === '1') {
                salt = line.substring(12);
            }
            else if (line[10] !== '0') {
                this.emit(Client.Events.DEBUG, 'Unkown greeting: ' + line);
            }
            this.setToken(salt);
            this.connected = true;
            this.emit(Client.Events.CONNECT);
        }
        else if (Object.values(ProtocolPrefix).includes(line.substring(0, 2))) {
            // Usual response
            const response = line.substring(2);
            const promise = this.cmdStack.shift();
            switch (response) {
                case Responses_1.ResponseCode.ERR1:
                case Responses_1.ResponseCode.ERR2:
                case Responses_1.ResponseCode.ERR3:
                case Responses_1.ResponseCode.ERR4:
                case Responses_1.ResponseCode.ERR5:
                case Responses_1.ResponseCode.ER401:
                    if (promise !== undefined) {
                        promise.reject(new Error(response));
                    }
                    break;
                case Responses_1.ResponseCode.ERRA:
                    this.emit(Client.Events.AUTHENTICATION_ERROR);
                    if (promise !== undefined) {
                        promise.reject(new Error(response));
                    }
                    break;
                default:
                    this.emit(Client.Events.DATA, response);
                    if (promise !== undefined) {
                        promise.resolve(response);
                    }
                    break;
            }
        }
        else if (Object.values(Responses_1.ResponseCode).includes(line)) {
            const promise = this.cmdStack.shift();
            switch (line) {
                case Responses_1.ResponseCode.ERRA:
                    this.emit(Client.Events.AUTHENTICATION_ERROR);
                    if (promise !== undefined) {
                        promise.reject(new Error(line));
                    }
                    break;
                default:
                    if (promise !== undefined) {
                        const description = Responses_1.getResponseDescription(line);
                        promise.reject(new Error(description));
                    }
                    break;
            }
        }
        else {
            this.emit(Client.Events.DEBUG, 'Unkown data received: ' + line);
        }
    }
    /**
     * Sends a command to the NT CONTROL host.
     * @param cmd   The command string (without CR at the end)
     * @param type  The command type (binary vs. ascii)
     * @returns     A promise with the response (string) from the host.
     */
    sendCommand(cmd, type = Types_1.CommandType.Binary) {
        if (this.socket !== undefined) {
            return new Promise((resolve, reject) => {
                if (this.socket !== undefined) {
                    try {
                        const prefix = (type === Types_1.CommandType.Binary) ? ProtocolPrefix.PERSISTENT_BIN : ProtocolPrefix.PERSISTENT_ASCII;
                        this.socket.send(this.token + prefix + 'ADZZ;' + cmd + PROTOCOL_LINE_BREAK);
                        const promiseRef = { resolve, reject };
                        this.cmdStack.push(promiseRef);
                        // Automatically resolve promise, if no response is received (not all cmds generate a response, but all might end with an error)
                        setTimeout(() => this.autoResolve(promiseRef), AUTO_RESOLVE_TIME);
                    }
                    catch (e) {
                        this.emit(Client.Events.DEBUG, 'Error sending data: ' + e);
                        // retry
                        this.once(Client.Events.CONNECT, () => this.sendCommand(cmd, type).then(resolve, reject));
                        // restart connection
                        this.connect();
                    }
                }
            });
        }
        else {
            return Promise.reject(new Error('No socket.'));
        }
    }
    /**
     * Closes the underlying TCP connection.
     */
    destroy() {
        if (this.socket !== undefined) {
            this.socket.removeAllListeners();
            this.socket.destroy();
            delete this.socket;
            this.connected = false;
            this.emit(Client.Events.DISCONNECT);
            // Resolve all pending requests.
            let promise = this.cmdStack.shift();
            while (promise !== undefined) {
                promise.reject(new Error('Socket closed.'));
                promise = this.cmdStack.shift();
            }
        }
    }
    autoResolve(promise) {
        const index = this.cmdStack.indexOf(promise);
        if (index >= 0) {
            this.cmdStack.splice(index, 1);
            promise.resolve();
        }
    }
}
exports.Client = Client;
/**
 * Enumeration of events emitted by the class.
 */
Client.Events = {
    CONNECT: 'connect',
    DISCONNECT: 'disconnect',
    DATA: 'data',
    END: 'end',
    DEBUG: 'debug',
    AUTHENTICATION_ERROR: 'auth_error'
};
//# sourceMappingURL=Client.js.map